<!--decor
## Lesta Core Framework

Simple and clear concepts, separation of JavaScript and HTML. Reactivity is achieved through the native properties of DOM nodes without using a virtual DOM. All of this provides incredible flexibility for integration with existing projects and other libraries.

<img src="https://github.com/lestajs/translation/assets/68551616/1532c892-dafd-46d4-8bb8-48f4fb676f0b" width="160px">
-->

# Quick start
```bash
npm i lesta
```
Чтобы использовать Lesta, загрузите последнюю версию или установите ее с помощью [npm](https://www.npmjs.com/package/lesta/).

Lesta использует классические модели декларативного и компонентного программирования и options API в качестве способа определения компонентов. 


## createWidget 
```js
import { createWidget } from 'lesta'
const root = document.querySelector('#root')
const widget = createWidget({
   … // component options
}, root)
// await widget.destroy() 
```
`createWidget` - легковесная функция, с помощью которой можно создать только один компонент (виджет). Эта функция доступна для подключения через СDN и представляется собой фреймворк с урезанным функционалом и наименьшим весом.

Для этой функции доступны только возможности описанные в разделе **Basic options** и **Lifecycle Hooks**.

Функция принимает два аргумента:

- **options** опции из раздела Basic options
- **root** DOM узел для встраивания виджета

`createWidget` возвращает объект с асинхронной функцией `destroy`. `widget.destroy()` уничтожит виджет.

## createApp
```js
import component from './app'
import { createApp } from 'lesta'

const root = document.querySelector('#root')
const app = createApp()
app.mount(component, root)
```

Функция используется для создания приложения с полным функционалом фреймворка.

Возвращаемое значение: объект с двумя функциями `mount` и `unmount`.

- `mount(component)` Необходимо передать объект компонента для монтирования.

- `unmount()` функция, демонтирует компонент.

> В качестве аргумента принимает объект. Все свойства этого объекта будут доступны в store и во всех компонентах как свойства объекта `this`.

# Basic options

## template
```js
export default {
  template: `<h1>Hello!</h1>`
} 
```
HTML код компонента задается в  `template`. Вы можете HTML код вынести в отдельный файл, импортировать в файле компонента и передать в качестве значения в поле template.

## nodes
```js
template: `<button class="next">+</button>`,
proxies: { count: 0 },
nodes() {
    return {
        next: {
            textContent: ({ offsetHeight, nodepath }) => `height: ${ offsetHeight }, node: ${ nodepath }`
            onclick: () => this.proxy.count++,
            disabled: () => this.proxy.count === 5
        }
…
```
```js
// nodes
profile: {
  href: () => this.router.link({ name: 'profile', params: this.method.locale() }),
  style: () => {
    return {
      visibility: this.proxy.auth ? 'visible' : 'hidden'
    }
  }
}
```
Функция **node** используется для связи функционала с HTML элементами, указаными в **template**. В опциях узлов доступны все методы и свойства соответвующего HTML элемента. Например `textContent` или `innerHTML`, `onclick`, `style` и т.д.). Функция `nodes` должна возвращать объект. Где ключи объекта соответствуют именам узлов. По умолчанию имена узлов соотносятся с селекторами классов.

Чтобы устанавливать значения для нативных свойств узла, достаточно в параметрах узла указать свойство в качестве ключа объекта, в качестве значения указать либо само значение, либо функцию, которая будет возвращать значение.

Такие нативные свойства, как `style` или `dataset` являются объектами. Чтобы избежать их полного переопределения а изменить только их некотрые свойства, в качестве значения необходимо передать функцию, которая возвращает объект с теми  свойствами, котрые необходимо переопределить.

Функция утстановленые в качестве значений свойств узла (не события), принимает один аргумент **node** - объект HTML элемента с двумя дополнительными свойствами:
- `nodepath` Путь, состоящий из имен узлов.
- `nodename` Имя узла компонента.

Используя деструктуризацию, можно из объекта узла получить нужные свойства.

Получить объект узла в компоненте можно через `this.node['имя узла']`.

## selector
```js
template: `
    <div class="wrapper">
      <div class="popup"></div>
      <main></main>
    </div>`,
  nodes() {
    return {
   }
}
```
Чтобы изменить селектор класса поумолчанию, в опциях объекта узла можно использовать специальное свойсто **selector**.

В качестве значения можно передать строку с новым селектором. Если передать функцию, то значение возвращаемое этой функцие будет определяться, как новый селектр. 

Для создания глобального правила определения селектора в приложении, необходимо метод **selector** задать в объекте пердаваемом в функцию `createApp`

Функция примнимает один аргумент: соответствующие имя узла. 


## directives

```js
const app = createApp({
root: document.querySelector('#root'),
directives: {
        _class: {
            update: (node, options, key) => {
                const value = typeof options[key] === 'function' ? options[key]() : options[key]
                value ? node.classList.add(key) : node.classList.remove(key)
         }
     }
}})
```
```js
// nodes 
    filter: {
      _class: {
        gray: () => this.proxy.showIncomplete
      },
      onclick: () => {
        this.proxy.showIncomplete = !this.proxy.showIncomplete
      }
```
```js
directives: {
    _intersection: {
      create: (node, options, directive) => {
        const observer = new IntersectionObserver(options.callback, {
          rootMargin: options.rootMargin || "0px",
          threshold: options.threshold || 1.0
        })
        observer.observe(node)
      }
    }
```
```js
// nodes
     more: {
        _intersection: {
          callback: (entries) => entries.at(0).isIntersecting && this.method.more()
        }
      }
```
Директивы позволяют расширить функционал node. Свойства директив могут иметь параметры или функции. Если в функции встречается `proxy`, то эта функция становится реактивной.

Директивы описываются в объекте `directives`, название директивы должно начинаться с `_`. Так как директивы применяются к узлам, такое обозначение позволяет отличать директивы от нативных методов и свойств `node`.

Для создания директив предоставляются две callback функции:

`create` Выполняется при обработки узла компонента. Принимает два аргумента:
	- `node` - объект узла, к которому применяется директива.
	- `options` - опции директивы, описаных в узле.

`update` Вызывается при реактивности для каждого параметра директивы. Помимо `node` и `options` принимает два дополнительных аргумента:
	-  `value` - значение получаемы при каждом вызове реактивной функции.
 	-  `key` - ключ опции соответствующей реактивной функуии.

`destroy` Выполняется когда компонент размонтируется.


> Обработка событий в директивах должна устанавливаться только через функцию слушателя `node.addEventListener`, так как в свойствах обработки событий `node` уже могут быть установлены функции.

> Директивы можно задавать, как в компоненте, так и глобально для всего приложения

Встроенные директивы: _html, _evalHTML,  _text, _class

## params
```js
params: {
  delay: 2000
}
...
console.log(this.param.delay)
```
В params можно описать данные, которые не требующие отслеживания изменений. Тип данных может быть любой. Доступны в компоненте через this.param['имя']

> После монтирования this.param не доступен для расширения. Уже созданые свойства вthis.param расширяются без ограничений.

## proxies
```js
proxies: {
  notifications: [],
}
…
methods: {
  async add(notify) {
    this.proxy.notifications.unshift(notify)
    await delay(this.param.delay)
    this.proxy.notifications.pop()
  }
}

```
В proxies описываются данные изменение которых необходимо отслеживать. Для каждого такого объекта будет создан объект-обертка proxy. Он доступен в компоненте через this.proxy. Изменение таких объектов можно отслеживать и использовать для реактивности.

> Все описанные в свойствах узла (node) функции, становятся реактивными, если в них присутствуют proxy. Эти функции будут вызываться при каждом изменении proxy обновляя свойства узла.

> Если вам не нужна реактивность для свойства, тогда значение нужно установить напрямуй без использования стрелочной функции: textContent: this.proxy.foo

> Свойства proxies не доступны для расширения. Нельзя добавить новый proxy после их создания. При этом существующие изменяются без ограничений.

> Все объекты устанавливаемые в прокси, проходят сериализацию. Таким образом происходит клонирование объектов. И при попытке сравнить такой объект с исходным, условие будет возвращать false.

> Свойства объектов которые имеют значение undefined при сериализации будут потеряны. Чтобы этого не произошло, в качестве значения рекомендуется устанавливать null.

> По умолчанию реактивные функции активируются только, если значение стало отличаться от предыдущего. Но если это ограничение нужно обойти, используйти setters.

## methods
```js
methods: {
  async add(notify) {
    …
  }
}
...
console.log(this.method.add)
```
```js
// parent component
this.node.notifications.method.add({ text: task.name })
```
Функции описанные в methods доступны в компоненте как this.method['имя'].

> Все методы дочернего компонента доступны в родительском через
this.node['имя узла'].method['название метода'].

## handlers
```js
proxies: {
  showIncomplete: false
},
handlers: {
  showIncomplete(v) {
    this.method.delayFilterStop()
  }
}
…
filter: {
  onclick: () => this.proxy.showIncomplete = !this.proxy.showIncomplete
},
add: {
  onclick: () =>  this.proxy.showIncomplete = false
}
```
В `handlers` описываются функции, которые срабатывают после изменения `proxy` объектов. В аргумент функций можно получать новое значение `proxy`. Имя функции задается в формате `keypath`.

`keypath` соответствует ключам вложенных свойств объекта `proxy` разделенными знаком “.”. Если `proxy` не имеет вложенности, то имя функции будет соответствовать имени `proxy`. Для `proxy` имеющих свойства, можно отслеживать изменение конкретных свойств. Например, если в `proxy` объекте `user: { age: 25 }` необходимо отследить изменение свойства `age`, то имя функции должно быть `user.age()`. Так как в `javascript` массив также является объектом, можно отслеживать изменение его элементов или длины: `array.0`, `array.0.name`, `array.length`, где `array` имя массива.

`handlers` особенно полезны, когда `proxy` меняется из нескольких мест и нужно выполнять одно и то же действие при его изменении.

## setters
```js
setters: {
    _card.completed(v) {
      if (typeof v !== 'boolean') {
        this.error('property completed in card: wrong data type')
        return false
      }
      return v
    }
  }
```
Функции описанные в setters перехватывают значение proxy до того как значение пройдет сериализацию и будет установлено. Для того чтобы значение было установлено функции setters должны возвращать значение. Имя функции должно соответствовать **keypath**, аналогично handlers.

> Если функция не вернет значение, то соответствующий proxy изменен не будет. Таким образом в setters можно контролировать реактивность и валидировать значения.

>! Поумолчанию реактивность работает только в том случаи если новое значение прокси отличается от предидущего. Это правило пересате работать, к только для прокси укзан setter. Здесь вы должны сами контролировать обновлять прокси с темже значением или нет.

## sources

```js
sources: {
    count: () => import('../count')
  },
  nodes() {
    return {
      count: {
        component: {
          src: this.source.count,
          induce: () => this.proxy.showCompleted
        }
      }
```
Для динамической загрузки модулей необходимо описать функции импорта sources. Далее к ним можно будет обратиться через this.source[‘имя модуля’]. Поле src в component автоматически выполняет функцию динамического импорта.

# Component properties
```js
import card from '../card/index.js'
nodes() {
    return {
      cards: {
        component: {
          src: card,
          params: {
            index: …
          },
          proxies: {
            _card: () => …
          },
          methods: {
            complete: () => …
          }
          // iterate: () => ...,
          // induce: () => ...,
          // sections: {},
          // abortSignal: this.abortSignal,
          // aborted: ({ phase }) => {}
        }
      }
    }
  }
```


Чтобы монтировать компонент в узел необходимо задать параметры для свойства component:

- `src` Ожидает объект компонента, который можно предварительно импортировать или определить в текущем файле.
- `params` Передаются данные, не требующие отслеживания. Чтобы в `params` передать ссылку на node, необходимо использовать стрелочную функцию.
- `proxies` Передаются proxy-объекты, которые будут обновляться на стороне дочернего компонента, работает только от родителя к потомку. Чтобы переданные прокси объекты были реактивными, в свойство необходимо передать функцию, в которой присутствует proxy объект. Такая функция может возвращать вычисляемые значения. Для глубинной синхронизации proxy, необходимо, чтобы имя свойства начиналось со символа “_”. Функция не должны иметь вычислений, она должны возвращать только proxy.
- `methods` Передаются функции или методы компонента, который можно будет вызывать на стороне дочернего компонента. `methods` должны быть свойством со стрелочной функцией, это сделано для того, чтобы можно было установить другой метод в качестве значения.

Все перечисленные выше свойства передаются в `props` дочернего компонента. Если в свойство объекта `proxies` не будет предана функция, изменять этот proxy из родительского компонента станет невозможно. Но на стороне дочернего компонента будет создан proxy с переданным значением.

В одном узле можно создать только один компонент.

Аналогично как и функции нативных свойств узлов, описанных выше, функции `params`, `proxies` в качестве аргумента принимают объект узла со всеми дополнительными свойствами. Исключения составляют итерируемые компоненты, подробная информация в разделе `iterate`.

## props
```js
props: {
    params: {
      time: {
        type: 'number',
        default: 2000,
        readonly: true
      }
    }
  }
```

```js
props: {
    params: {
	// …
    },
    proxies: {
      notify: {
        type: 'object',
        required: true,
        // default: ...
        // store: ''
      }
    },
    methods: {
      close: {
        required: true
      }
    }
  }
```
Чтобы получить данные от родительского компонента, необходимо указать их в объекте props: `params`, `proxies`, `methods`. В `methods` мы можем получить коллбэк функции от родительского компонента, которые можно использовать для коммуникации компонентов от потомка к родителю.

Дополнительные опции `props`:

`params`

- `required` [`boolean`] Проверка, чтобы значение не было пустым.
- `type` [`string`] Проверка на соответствие типу.
проверка осуществляется по стандарным javaScript типам и одному дополнительному не нативному типу array.
- `default` Задает значение по умолчанию.
- `store` [`string`] Имя store из которого необходимо принять `prop`.
- `readonly` [`boolean`] Делает значение неизменяемым.
- `ignore` [`boolean`] Такие параметры не проходят сериализацию.

`proxies`

- `required` [`boolean`] Проверка, чтобы значение не было пустым.
- `type` [`string`] Проверка на соответствие типу. проверка осуществляется по стандарным javaScript типам и одному дополнительному не нативному типу array.
- `default` Задает значение по умолчанию.
- `store` [`string`] Имя store из которого необходимо принять `prop`.

Переданный в компонент `proxy` обязательно должен быть принят в `props`.
Валидация значений происходит не только при создании компонента, но и в runtime (не работает для `proxy`, имя которых начинается с '_').

`methods`

- `required` [`boolean`] Проверка, чтобы значение не было пустым.

> Все объекты передаваемые между компонентами проходят стерилизацию. Таким образом создаются копии этих объектов. Если передаются объекты, то значения свойств должны быть таких типов, которые поддерживает `JSON`.

> Все полученные `props` становятся частью компонента и доступны как `this.param`, `this.proxy`, `this.method`.

> Даже если `props` приняты, но не переданы, то на стороне дочернего компонента, они все равно будут созданы в `this.param`, `this.proxy`. Поэтому `param` и `proxy` можно создавать указав их в `props`.

> Для глобального контекста this используйте стрелочную функцию. 

## induce
```js
proxies: {
    showCompleted: false,
  },
  nodes() {
    return {
      count: {
        component: {
          src: this.source.count,
          induce: () => this.proxy.showCompleted // mount component if condition true
          // induce: () => true
        }
      },
      filter: {
        onclick: () =>  this.proxy.showCompleted = !this.proxy.showCompleted
      }
```
Иногда необходимо, чтобы компоненты создавались только по какому-то условию. Условие необходимо указать в функции induce.

Изменение proxy объекта в функции induce, при условии **true** заново монтирует компонент, предварительно вызывая unmount.

> Монтируются асинхронно по мере готовности, вне потока монтирования основного компонента. Если нужно вытащить из основного потока монтирование компонента можно использовать induce: () => true

>! Не работает для sections

## iterate
```js
nodes() {
    return {
      notifyList: {
        component: {
          src: notify,
          iterate: () => this.proxy.notifications,
          params: {
            index: (notify, index) => index
          },
          proxies: {
            notify: (notify) => notify
          },
          methods: {
            close: (index) => this.proxy.notifications.splice(index, 1)
          }
        }
      }
    }
  }
```
Для создания компонентов в цикле в свойство iterate необходимо передать либо массив, либо функцию которая возвращает proxy объект массива.

Если функция возвращает proxy объект массива, то изменения этого объекта будут удалять или создавать новые компоненты или обновлять функции proxies передаваемые в props итерируемых компонентов.
Функции передаваемы в props компонентов, предоставляют два аргумента. В первый приходит текущий обрабатываемый элемент в массиве. Во второй индекс текущего обрабатываемого элемента в массиве.

> Для proxy объекта массива, в свойство iterate обязательно нужно передать функцию.

> Template интегрируемого компонента обязательно должен иметь один корневой тег.

> Монтируются асинхронно по мере готовности, вне потока монтирования основного компонента.

> Не работает для sections

## sections
```js
// dialog component
 template: `
  <dialog class="dialog">
    <div class="close"></div>
    <div section="content"></div>
  </dialog>`

// parent component
popup: {
  component: {
    src: dialog,
    sections: {
      content: {
	// src: …			
	// params: {},
	// proxies: {},
	// methods: {}
      }
    }
  }
}
```
`sections` позволяет интегрировать из родительского компонента в дочерний другие компоненты, в заранее выбранные теги (секции). В template дочернего компонента необходимо задать теги с атрибутами section, значениями этих атрибутов будут именами секций. В родительском компоненте в component properties нужно описать объект sections. Свойства этого объекта будут соответствующие имена секций. Значениями этих свойств могут быть component properties: src, params, proxies, methods. Если component properties отсутствуют, то компонент можно будет интегрировать динамически. Коммуникация с такими компонентами доступна только из родителя.

Свойство узла секции **nodepath**, помимо пути узла в конце имеет имя секции.

Монтируются асинхронно по мере готовности, вне потока монтирования основного компонента.

>! induce и iterate не поддерживаются 

## section mounting
```js
this.node.popup.section.content.mount({
	src: form,
	params: {
	  card: task,
	},
	methods: {
	  save: () => { }
	}
  })
```
Функции mount позволяет динамически интегрировать компонент в секцию. Для этого в функцию необходимо передать два параметра. Функция является асинхронной и с помощью не можно контролировать порядок монтирования секций.

this.node['имя узла'].section[‘имя секции’].mount(component options)

Если в функцию mount не передать значения, то будет монтировать компонент получению, тот что описан в sections. Если компонент по умолчанию не задан, то mount просто размонтирует компонент который был до этого.


Получить доступ к узлам секций в родительском компоненте можно с помощью
this.node['имя узла'].section['имя секции']

this.node['имя узла'].section['имя секции'].method['название метода']
Демонтировать компонент из секции можно с помощью
this.node['имя узла'].section['имя секции'].unmount()

## unmount
```js
this.node.mycomponent.unmount()

```
Эта функции демонтирует компонент из узла. this.node['имя узла'].unmount()

# Lifecycle Hooks
На разном этапе жизни компонента доступны следующие функции:

- `loaded`
Вызывается после загрузки файла компонента, но до обработки всех опции. На этом этапе все опции компонента будут доступны в this.options.
this.options.inputs (for props)

- `rendered`
Вызывается после рендера содержимого template. После выполнения этого хука доступен this.container (узел компонента)

- `created`
Вызывается перед обработкой nodes, но после обработки всех props, params, proxies, methods.

- `mounted`
Вызывается после обработки всех узлов и дочерних компонентов.
не вызывается в серверных компонентах

- `unmounted`
Вызывается после удаления HTML содержимого родительского узла компонента.
не вызывается в серверных компонентах (не асинхронный)

Во всех компонентах на всех этапах доступен корневой узел как this.root. 

Все хуки являются асинхронными функциями и выполняются в строгой последовательности. Если одна их этих функций вернёт не ложное и не пустое значение, но цепочка выполнения прервется. Обрабатывать эти ошибки можно на стороне родительского компонента (подробнее в разделе aborted)


