## Lesta Basic
Lesta Basic — a documentation section with the framework’s core API and its lightweight version for single-component widgets. 
All code examples are extracted from our [examples repository](https://github.com/lestajs/exapmles)

<img src="https://github.com/lestajs/translation/assets/68551616/1532c892-dafd-46d4-8bb8-48f4fb676f0b" width="150px">
<!--decor-->

# Quick start
```bash
npm i lesta@latest
```
Lesta — нативный JavaScript-фреймворк для создания пользовательских интерфейсов для Web. Он построен на базе стандартных HTML, CSS и JavaScript. Предоставляет декларативную модель программирования на основе компонентов и реактивности.

Чтобы использовать Lesta, загрузите последнюю версию или установите ее с помощью [npm](https://www.npmjs.com/package/lesta/).

## createApp
```js
import component from './app'
import { createApp } from 'lesta'

const root = document.querySelector('#root')
const app = createApp({ name: 'myproject' })
app.mount(component, root)
```
Создание приложения начинается с вызова этой функции. В качестве параметра  функция ожидает объект с опциями (необязательный). Все свойства этого объекта будут доступны в компоненте как свойства объекта this.app. После создания this.app не доступен для расширения новыми свойствами.

Опции:
- name` (строка, необязательный): имя корневого узла (по умолчанию "_"). Отображается в тексте ошибок в консоле браузера.

Возвращаемое значение:
- `mount` функция: добавляет корневой компонент в заданный DOM узел.

**mount**
Возвращаемое значение:
 `unmount` функция: ударяет корневой компонент приложение из DOM.

Параметры:
- `component` объект с опциями корневого компонента.
- `target` DOM узел для монтирования корневого компонента.


## mountWidget

```js
import { mountWidget } from 'lesta'
const root = document.querySelector('#root')
const app = {
  aborted: () => {},
  completed: () => {},
  id: 0 
}
const widget = mountWidget(component, root, app, 'widget')
// await widget.unmount() 
```
Монтирует компонент (виджет) в указанный узел. Функции является облегченной версией фреймворка, создание вложенных компонентов не поддерживается.
CDN модуль lesta.widget.global создает глобальную переменную lesta в которой доступный следующие методы: mountWidget, replicate, revocablePromise.

Параметры:
- `component` объект компонента (виджета).
- `target` DOM узел для встраивания виджета.
- `app` (объект, необязательный): Все свойства этого объекта будут доступны в компоненте как свойства this.app.
- `name` (строка, необязательный): имя корневого узла (по умолчанию "_"). Отображается в тексте ошибок в консоле браузера.

Опции параметра app: aborted, completed, id, selectors… (описаны ниже)


Возвращаемое значение:
 `unmount` функция: ударяет корневой компонент приложение из DOM.


> Для mountWidget доступны возможности описанные только в разделе `Basic Options`.

# Basic Options
Компоненты имеют вид опций, где каждый раздел имеет свою логику (options API).

- `immutable`
В основе работы Lesta лежит принцип иммутабельности. Иммутабельность реализуется с помощью сериализации JSON.stringify(). Это самый быстрый способ клонировать объекты. Но он имеет важный недостаток, данные в объектах могут быть только тех типов, которые поддерживает стандарт JSON: строка, число, объект (объект JSON), массив, boolean, null.

- `reactive properties`
Данные, которые требуют отслеживание изменений в компоненте оборачиваются в proxy-объекты. Далее эти данные можно связать с реактивными свойствами.
- `reactive function`
Функции, в которых есть обращение к proxy-объектами считаются реактивными. При изменении proxy-объекта эти функции будут выполнены, а соответствующие свойства будут обновлены.

> Не изменяйте proxy-объекты в функциях реактивных свойств, это приведет к бесконечному вызову функции.

## template
```js
export default {
  template: `<h1>Hello!</h1>`
} 
```
```js
import template from 'bundle-text:./index.html' // for Parcel
export default {
    template, // HTML-string from file
} 
```
```js
  template() {
    const idName = this.appId()
    return `
      <div>
        <label for="${idName}">Name</label>
        <input id="${idName}" class="name" type="text">
      </div>
      <button class="save">Save</button>`
  }
```
HTML код компонента задается в `template`. В качестве значения свойство ожидает строку или функцию. У функции будет доступен контекст this.

Использование HTML из ненадежных источников, является угрозой безопасности. Не передавайте его в `template` и innerHTML. Если вы получите HTML в результате пользовательского ввода, используйте библиотеки санитайзеры. Если вы используете одну из них, вам следует следить за обновлениями безопасности. Используйте дополнительные средства защиты, такие как Content Security Policy (CSP), белые списки и другие. Защита от XSS — это постоянный процесс, требующий внимания на всех этапах разработки.

**appId**

Часто бывает необходимость связать элементы формы по id. Метод this.appId() возвращает строку состоящую из префикса “_” и числового значения счетчика. Каждый вызов в приложении прибавляет счетчик на единицу. Таким образом гарантируется уникальность id в рамках одного приложения.

> Если значение template не задано, поиск узлов будет осуществляться в родительском узле родительского компонента.

## nodes
```js
nodes() {
…
button: {
    className: this.param.className,
    onclick: this.method.action,
    textContent: () => this.proxy.text
}
```
```js
nodes() {
…
      line: {
        style: () => {
          return {
            backgroundColor: this.proxy.card.completed ? 'var(--yellow)' : ''
          }
        }
      }
```
Функции nodes должна возвращать объект, свойства которого будут именами узлов, с которыми необходимо связать какой либо функционал. По умолчанию имя узла соответствует имени класса HTML элемента указанного в `template`.

Свойства узлов фреймворка соответствуют методы и свойствам DOM узлов, таких как `textContent` или `innerHTML`, `onclick`, `style` и т.д. 

Такие свойства, как `style` или `dataset` являются объектами. Чтобы изменить параметры таких свойств, в качестве значения необходимо передать функцию, которая возвращает объект только с теми вложенными свойствами, которые нужно изменить.

Функции событий вида on<событие> получают в качестве параметра объект события.

В компоненте объект узла  доступен, как this.node.<имя узла>

Свойства:
- `nodepath` Путь, состоящий из имен узлов
- `nodename` Имя узла компонента
- `target` DOM узел

## styles
```js
import styles from './index.module.css' 
…
template: `
  <dialog class="dialog">
    <div class="close"></div>
    <div spot="content"></slot>
  </dialog>`,
styles, // {close: 'cMwCXa_close', dialog: 'cMwCXa_dialog'}
nodes() {
    return {
      dialog: {},
      close: {...}
…
```
Файлы со стилями импортируются в самом файле компонента. Изоляцию стилей можно организовать несколькими способами: CSS modules или внимательное использование CSS Nesting (не гарантирует полную изоляцию).

## selectors
```js
template: `
    <div class="wrapper">
      <div class="popup"></div>
      <main></main>
    </div>`,
  nodes() {
    return {
      main: {
           selector:  'main',
           // selector: (name) => name
      }
   }
}
```
```js
const app = createApp({
  selectors: (name) => '.' + name.replace('_', '-'),
}
```
По умолчанию имя узла соответствует селектору класса HTML элемента. Селектор можно для узла можно изменить в свойстве selector. Это свойство ожидает в качестве значения строку или функцию, которая возвращает строку с необходимым селектором.
Функция selector в качестве параметра принимает имя узла, которое можно использовать для генерации нужного селектора. Функцию для генерации селектора можно задавать, как для каждого узла отдельно в свойстве selector. Или глобально для всего приложения, описав ее в свойстве опций selectors для createApp.

## directives

```js
const app = createApp({
  directives: { // global directives
     _move: {
       update: (node, value) => {
	if (value.contains(node.target)) return
	value.appendChild(node.target)
        }
      }
    }
})
```
```js
directives: { // directives in component
  _teleport: {
      create: (node, value) => value.append(node.target)
  }
},
nodes() {
    return {
      popup: {
        _teleport: document.body,
```
Директивы позволяют расширить функционал узлов. Свойства директив могут иметь параметры или реактивные функции. Директивы описываются в объекте `directives`, название директивы должно начинаться с `_`. Такое обозначение позволяет отличать директивы от нативных методов и свойств узлов.

Директивы описываются с помощью следующих функций:

**create** Выполняется при обработки узла компонента.
Параметры:
-`node`: Объект узла, к которому применяется директива.
-`options`: Параметры директивы, применяемой к данному узлу.

**update** Выполняется для каждого параметра директивы. 
Параметры:
-`node`: Объект узла, к которому применяется директива.
-`value`: Значение свойства директивы.
-`key`: Ключ параметра (свойство). Если параметр является реактивной функцией, то update будет вызываться при каждом реактивном изменении этого параметра.

**destroy** Выполняется когда компонент размонтируется. Имеет те же параметры что и функция create.

В качества значения опции директивы могут принимать реактивные функции с теми же параметра, как в функциях create и destroy.

> `node` не является ссылкой на реальный DOM элемент, дуступ к элементу можно получит через node.target.

> Директивы можно задавать, как в компоненте, так и глобально для всего приложения, описав их в createApp.

Встроенные директивы: 
`_text`: Добавляет текстовое содержимое узлу по аналогии textContent. Не выводит undefined, выводит объекты в виде текста.

`_class`:Добавляет классы элементу узла, с возможностью реактивного переключения. В качестве значения ожидает объект, где свойствами являются классы, а значениями функции, возвращение булево значение.

`_attr`: Добавляет атрибуты элементу узла, с возможностью реактивного переключения. В качестве значения ожидает объект, где свойствами являются атрибуты, а значениями функции, возвращение булево значение.

`_event`: Добавляет слушателей элементу узла с помощью addEventListener. После размонтирования компонента слушатели автоматически удаляются. В качестве значения ожидает объект, где свойствами являются события, а значениями функции обработчики.

## params
```js
params: {
    max: 5
},
nodes() {
…
    next: {
        onclick: () => this.proxy.count++,
        disabled: () => this.proxy.count === this.param.max
    }
}

```
В params описываются общие переменные необходимые компоненту, которые не участвуют в реактивности. Доступны в компоненте как this.param.

## proxies
```js
proxies: {
    count: 0
},
nodes() {
…
    result: {
        textContent: () => this.proxy.count
    },
    prev: {
        onclick: () => this.proxy.count--,
        disabled: () => this.proxy.count === 0
    }
```
В proxies описываются данные изменение которых отслеживается в реактивных функциях. Доступны в компоненте как this.proxy.

> Все стрелочные функции, описанные в внутри функции nodes() становятся реактивными, если в них присутствуют proxy. Изменения proxy объектов вызывают обновления в компоненте (принцип реактивности).

> Все объекты устанавливаемые в proxies, проходят сериализацию. Таким образом происходит клонирование объектов. И при попытке сравнить такой объект с исходным, условие будет возвращать false.

> Свойства объектов которые имеют значение undefined при сериализации будут потеряны. Чтобы этого не произошло, в качестве значения рекомендуется устанавливать null.

> По умолчанию реактивные свойства обновлятся только, если новое значение стало отличаться от предыдущего. Если это ограничение нужно обойти, можно использовать setters (ссылка).

## methods
```js
nodes() {
…
    buttons: {
        onclick: (e) => {
            const target = e.target.closest('.buttons > button')
            if (target) this.method[target.name]() // this.method.dark() or this.method.light()
        }
    }
},
methods: {
    dark() {
        alert('Dark Theme')
     },
     light() {
        alert('Light Theme')
     }
}
```
В methods можно описать все необходимые для компонента функции. Доступны в компоненте как this.method.

## actions
```js
// dialog component
actions: ['show', 'close'],
methods: {
    show() {...},
    close() {...}
}
// main component
nodes() {
    return {
      popup: {
        component: { src: dialog, …}
…
this.node.popup.action.show() 
```
Свойство `actions` ожидает массив строк, с перечислением методов, которые необходимо сделать доступными для вызова в родительском компоненте.
В родительском компоненте такие методы будут доступны как this.node.<название узла>.action.<название метода>()

> Данные переданные в `actions` функции в качестве аргументов и данные, которые эти функции возвращают проходят сериализацию, обеспечивая иммутабельность.

## handlers
```js
handlers: {
   opened(v) {
     v ? this.node.dialog.target.showModal() : this.node.dialog.target.close()
   }
}
```
В `handlers` описываются функции, которые вызываются после изменения одноименных proxy объектов.

Имя функции задается в формате `keypath` и соответствует именам свойств объекта proxy разделенными точкой в формате строки. Например, если в `user: { age: 25 }` необходимо отследить изменение свойства `age`, то имя функции должно быть ‘user.age’(). Так как в javascript массив также является объектом, можно отслеживать изменение его элементов или length: array.0, array.0.name, array.length.

В качестве параметра функции принимает значение proxy после его изменения.

`handlers` функции особенно полезны, когда proxy меняется в разных местах компонента и нужно выполнять одно и то же действие при его изменении.

## setters
```js
setters: {
   opened(v) {
     return typeof v === 'boolean' ? v : false
   }
 }
```
Функции описанные в `setters` работают аналогично функциям `handlers`, только они перехватывают значение proxy до того как значение пройдет сериализацию и будет изменено. Значение которое вернет эта функция будет установлено для соответствующего proxy в качестве нового значения.

> Если функция не вернет значение, то соответствующий proxy изменен не будет. Таким образом в setters можно контролировать реактивность.
> Попытка присвоить новое значение для proxy внутри функции привет к бесконечному вызову.


## sources

```js
  sources: {
    addForm: () => import('./components/form'),
    editForm: () => import('./components/form')
  }
…
  methods: {
    createForm({ mode, data }) {
      this.node.popup.spot.content.mount({
        src: this.source[mode + 'Form'],
…
```
В `sources` можно описать функции для динамической загрузки модулей. В компоненте доступны как this.source.

Динамическая загрузка модулей может используется для подгрузки компонентов по условию, подробнее в разделе induced (ссылка) или в функции mount().


## Lifecycle Functions
```js
// module component
export default {
  template: ``,
  nodes() {...},
  loaded() {},
  created() {},
  rendered() {},
  mounted() {},
  unmounted() {},
  refreshed() {}
}
```

На разном этапе жизненного цикла компонента доступны следующие функции:

- `loaded`
Вызывается до обработки всех свойств компонента(опций). На этом этапе доступны все опции компонента в this.options.

- `created`
Вызывается перед обработкой nodes(), но после обработки всех props, params, proxies, methods. На этом этапе доступны this.param, this.proxy, this.method.

- `rendered`
Вызывается после встраивания template компонента в DOM.

- `mounted`
Вызывается после обработки всех узлов и монтировании дочерних компонентов. На этом этапе доступны this.node.

- `unmounted`
Вызывается после размонтирования компонента. Размонтировать компонент можно на стороне родительского компонента вручную this.node.<my component>.unmount().

- `refreshed`
Сообщает компонентам о каких либо внешних изменениях. Вызывается, после вызова метода refresh в родительском компоненте, как this.node.<my component>.refresh({ cause: 'cause', data: {}}) (обязательный параметр - объект с полем cause). Вызывается во всех дочерних комаонентах, на а всех уровнях вложенности.

> Все функции жизненного цикла поддерживают асинхронные операции (использование `await`). Кроме `unmounted` и `refreshed` все функции выполняются в строгой последовательности.

## completed
Функция вызывается на стороне родительского компонента, когда в дочерним компоненте все функции жизненного цикла были успешно выполнены. Функция completed передается в дочерний компонент, как и другие пропсы (params, proxies, methods, aborted, completed).

## aborted
На каждом этапе выполнения функции жизненного цикла можно вызвать прерывание с помощью this.abort(). Прерывание вызывает aborted на стороне родительского компонента, по аналогии с completed. Также функция aborted вызывается при размонтирование дочернего компонента.

Параметры (объект):
- `phase` значение от 0 до 5 соответствующие порядковому номеру функци жизненного цикла, в котором было выполнено прерывание.
- `reason` значение переданное в функцию abort().




## abortSigna
На каждом этапе выполнения функции жизненного цикла в компоненте доступен объект this.abortSigna. Это интерфейс представляет собой объект сигнала созданный [new AbortController()](https://developer.mozilla.org/ru/docs/Web/API/AbortSignal).

Несколько полезных способов использования сигнала:
- Удаление слушателя
<element>.addEventListener('<event>', () =>{}, { signal: this.abortSignal })
- Отмена запроса
fetch(url, { signal: this.abortSignal.timout(3000) })


# Component Options

API описанный ниже не поддерживается для виджетов, виджет-модуль является облегченной версией фреймворка и не поддерживает вложенность компонентов.

```js
import card from '../card/index.js'
nodes() {
    return {
      cards: {
        component: {
          src: card,
          iterate: () => this.proxy.tasks,
          proxies: {
            card: ({ index }) => this.proxy.tasks[index]
          },
          spots: {
            bottom: {
	  component: {...}
}
          },
          // params: {...},
          // methods: {...},
          // async: true,
          // aborted: () => {...},
          // completed: () => {...},
          // portion: 12,
          // induced: () => {...},
…
```

Свойство `component` служит для определения компонента в узле. 

Основные опции компонента:
- `src` Объект встроенного в узел компонента.

- `params` Пропс данные для дочернего компонента, не требующие отслеживания. Если передана функция, то она будет выполнена а результат ее выполнения будет передан в дочерний компонент в качестве значения.

- `proxies` Реактивные данные, которые будут автоматически обновляться в дочернем компоненте, в случае их изменении в родительском. В качестве значений `proxies` свойств указываются стрелочные функции с прокси объектами (this.proxy).

- `methods` Callback Функции, которые будут вызываться на стороне дочернего компонента и передавать данные от потомка к родителю.

- `async` принимает boolean значение. Если true, то монтирование компонента будет асинхронным. По умолчанию компоненты монтируются в последовательности указанной в функции nodes.

Информация по дополнительным опциям: iterate, portion, induced, spots, aborted, completed будет представлена в других разделах.

> Все передаваемые данные между компонентами проходят сериализацию.

> По умолчанию, компоненты монтируются в HTML элемента узла. Если тегом узла является <template>, то компонент монтируется вместо этого тега. (`replaced nodes`)

## props
```js
props: {
    params: {
      index: 'number',
      // index: {
      //   type: 'number,
      //   default: 0,
      //   readonly: true,
      //   mutable: true, // only for param,
      //   required: true
      // }  
    },
    proxies: {
      notice: {
        type: 'object',
        default: {},
        validation(value) {
          return typeof value.text === 'string'
        }
      }
    },
    methods: {
      close: true, // required: true
    }
}
```
Чтобы получить данные из родительского компонента или из хранилища, необходимо указать их props: params, proxies, methods. Свойства этих объектов должны соответствовать именам, принимаемых данных.

`params`
- `required` [`boolean`] Проверка, чтобы значение не было пустым.
- `type` [`string`] Проверка на соответствие типу.
проверка осуществляется по стандартным javaScript типам и одному дополнительному не нативному типу array.
- `default` Задает значение по умолчанию.
- `enum` [`array`] Перечисление допустимых значений.
- `store` [`string`, `function`] В качестве значения ожидает имя store.
- `mutable` [`boolean`] значения не проходят сериализацию.

`proxies`
- `required` [`boolean`] Проверка, чтобы значение не было пустым.
- `type` [`string`] Проверка на соответствие типу. проверка осуществляется по стандартным javaScript типам и одному дополнительному не нативному типу array.
- `default` Задает значение по умолчанию.
- `enum` [`array`] Перечисление допустимых значений.
- `store` [`string`] В качестве значения ожидает имя store.
- `validation` [`function`] Дополнительная возможность проверки входных данных и вложенных объектов. Здесь можно проверять и переопределять свойства вложенных объектов. В качестве параметра функция получает значение prop. В этой функции доступен контекст компонента this.

`methods`
- `required` [`boolean`] Проверка, чтобы значение не было пустым.

Существует упрощенный способ задать опции валидации. Для prop можно сразу указать значение одной из опций: для `params`, `proxies` это опции type[`string`]  или enum[`array`]. Для `methods` это required [`boolean`].

> Все объекты передаваемые между компонентами проходят стерилизацию. Таким образом создаются копии этих объектов. Если передаются объекты, то значения свойств должны быть таких типов, которые поддерживает `JSON`.

> Props методы могут работать только с одним параметром (объектом). С помощью деструктуризации можно получить доступ только к нужным  свойствам.

> Все полученные props становятся частью компонента и доступны как `this.param`, `this.proxy`, `this.method`.

> Если props описаны в компоненте, но не были переданы, они все равно будут созданы в `this.param`, `this.proxy`. Такие props называются `unrelated`.

> Иногда может понадобится узнать является ли proxy самостоятельным (unrelated) или он может быть изменен вне компонента. Для этого можно использовать метод this.unrelatedProxy(<proxy-name>). Функция вернет true, если proxy независим и может быть изменен только в самом компоненте.

## induced
```js
component: {
  induced: () => this.proxy.isModify,
  src: this.source.modify,
  proxies: {
    card: ({ parent }) => this.proxy.tasks[parent.parent.index]
  }
}
```
Иногда необходимо, чтобы компоненты монтировался только по какому-то условию. Для этого можно использовать свойство induced. Ожидает реактивную функцию с условием, которое возвращает boolean значение. Если функция возвращает true компонент будет монтован, если false размонтирован.

## spots
```js
// component with spots
template: `
    <dialog class="dialog">
      <div class="close"></div>
      <div spot="content"></slot>
    </dialog>`,
  spots: ['content'],
…
refreshed({ cause, data }) {
    // cause = 'spotMounted'
    if (data.spotname === 'content') this.proxy.opened = true
  }
```
```js
// parent component
popup: {
        component: {
          src: dialog,
          spots: {
            content: {
              component: {} // for later mounting
            }
          }
…
// this.node.popup.spot.content.mount(...)
```
`spots` позволяют пробрасывать компоненты из родительского компонента в заранее подготовленные теги дочернего компонента. Чтобы обеспечить такие взаимодействие в template дочернего компонента необходимо создать теги с атрибутами spot с именами в качестве значений. Далее в свойстве `spots` перечислить все имена в виде массива строк.

В родительском компоненте, в свойстве component соответствующего узла нужно описать объект `spots`, с теми же именами. Для каждого свойства будут доступны те же свойства узла, как если бы узел spot находился в этом компоненте.

> Чтобы использовать функцию mount для монтирования компонента в spot, необходимо в свойствах соответствующего spot добавить пустой объект component: {}.

> Когда в дочернем компоненте происходит монтирование или демонтирования spot компонентов срабатывает функция жизненного цикла refreshed({ cause, data }).
-`cause` (строка): со значениями spotMounted или spotUnmounted
-`data` (объект): со свойством { spotname }.

## iterate
```js
component: {
          src: card,
          iterate: () => this.proxy.tasks,
          proxies: {
            card: ({ index }) => this.proxy.tasks[index]
          },
          spots: {
            bottom: {
              component: {
                src: controls,
                proxies: {
                  card: ({ parent }) => this.proxy.tasks[parent.index]
                },
...
```
Для создания компонентов в цикле в реактивное свойство iterate необходимо передать функцию, которая возвращает массив.

Если функция возвращает proxy объект массива, то изменение этого объекта будет обновлять соответствующие компоненты в узле.

Для props функций свойств params и proxies доступен параметр (объект узла - раздел nodes), с дополнительным свойствами:
-`index`: Порядковый номер узла.
-`parent`: Объект родительский узел.
-`‎iterated`: Имеет значение true.

В сочетании со свойством **iterate** доступно свойство **portion**. Это свойство ожидает числовое значение, которое соответствует количеству обновляемых/создаваемых компонентов в рамках одной event Loop итерации. В <portion> указывается количество обрабатываемых компонентов, после которых будут обрабатываться другие пользовательские события. Такой подход позволяет добиться наилучшей отзывчивости интерфейса.

> Template интегрируемого компонента должен иметь один корневой тег.

## mixins
```js
// button component
export default {
  template: `<button></button>`,
  props: {,
    proxies: {...},
    methods: {...}
  },
  nodes() {
    return {
      button: {...}
    }
  }
}
// new component
import button from '../button'
export default {
  mixins: [button],
  props: {
    proxies: {...}
  },
  nodes() {
    return {
      button: {...}
   }
  },
  created() {
    // button.created()
    // other code
   }
}
```

В свойство mixins можно передать массив с объектами компонентов, которые нужно подмиксовать к основному компоненту. Над всеми опциями компонентов типа объект и объектами функции узлов будет проведена операция слияния. Свойства template и все функции жизненного цикла будут переопределены. При необходимости, функции жизненного цикла подмиксованых компонентов можно вызывать в соответствующей функции основного компонента. Чтобы лучше понять механизм слияния компонентов лучше посмотреть исходники функции [mixins](https://github.com/lestajs/core/blob/main/packages/lesta/mixins.js])

