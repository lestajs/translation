# Store
Фреймворк поддерживает создания множества хранилищ. Каждое хранилище должно иметь уникальное имя, которое будет используется в качестве ключа объекта.

createStore({  })

# Store options

## params
В params можно описать любые данные не требующие отслеживания изменений. Аналогично params в компонентах.

## proxies
В proxies описываются данные изменение которых необходимо отслеживать. Аналогично proxies в компонентах.

## methods
```js
```
Функции описанные в methods могут принимать только один объект в качестве аргумента. Поэтому для получения нужных данных необходимо использовать реструктуризацию.

## middlewares
```js
```
Для каждого вызова метода в сторе можно предварительно вызывать одноименную функцию в объекте middlewares. Данные функции могут быть асинхронными. Они принимают тот же объект метода в качестве аргументы. И могут вернуть в метод уже измененный объект.

## sources
Для динамической загрузки модулей и компонентов необходимо описать функции импорта в опции sources.

## setters
Перехват изменения прокси. Аналогично setters в компонентах.

## store in component

```js
props: {
    proxies: {
      tasks: { store: 'tasks' }
    },
    methods: {
      // loadTasks: { store: 'tasks' },
      ...mapProps(['loadTasks', 'add', 'edit', 'remove', 'complete', 'search', 'filter', 'delayFilterStop'], { store: 'tasks' })
    }
}
…
async created() {
    this.method.loadTasks() // with await
}
```
Чтобы связать store с компонентом необходимо принять (params, proxies, methods) в props как если бы это был родительский компонент. При необходимости можно использовать утилиту mapProps для более короткой записи.

Изменения proxy в store автоматически обновляют proxy во всех компонентах в которых он был принят через props. Поэтому есть два способа использования загрузки данных в компоненте: Используя функцию жизненного цикла create можно вызвать метод загрузки данных в store без await. В таком случае монтирование компоненте произойдет и кода данные прейдет компонент реактивно обновится. Если использовать асинхронные вызов через метода, то можно прервать выполнение жизненный цикл компонента, тем самым избежать лишних вычислений.

Методы загрузки данных рекомендуется вызывать из общего родительского компонента и передавать данные вниз. В противном случае, чтобы избежать множественного вызова рекомендуется использовать middleware функцию и, булеву переменную-флаг в params, для отслеживания статуса первого вызова.
